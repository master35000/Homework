from random import randint
class BoardException(Exception):                                                    # Исключение
    pass

class BoardOutException(BoardException):                                     # Исключение
    def __str__(self):
        return 'Вы пытаетесь выстрелить за доску'


class BoardUsedException(BoardException):                                   # Исключение
    def __str__(self):
        return 'Вы уже стреляли в эту клетку'


class BoardWrongShipException(BoardException):                            # Исключение
    pass

class Dot:
    def __init__(self, x,y):                        # конструктор класса Dot
        self.x = x                                  # присвение значения параметру Х обекта
        self.y = y                                  # присвение значения параметру У обекта

    def __eq__(self, other):                        # переопределение метода сравнения для сравнения координат точки
        return self.x == other.x and self.y == other.y

    def __repr__(self):                              # определение метода представления класса DOT
        return f'Dot({self.x}, {self.y})'

class Ship:
    def __init__(self, fp, lives, v_g):              # конструктор корабля, принимает параметры первой точки, количества жизней (длинны корабля), вертикальной/горизонтальной ориентации
        self.fp = fp                                 # присвение значения параметру первой точки обекта
        self.lives = lives                           # присвение значения параметру жизней обекта
        self.length = lives                          # присвение значения параметру длинны обекта
        self.v_g = v_g                                 # присвение значения параметру ориентации обекта (0 - горизонтальная, 1 - вертикальная)


    @property
    def dots(self):                                   # метод создания корабля
        ship_dots = []                                # создание списка точек корабля
        for i in range (self.length):                  # цикл добавления точек корабля
            x = self.fp.x                         # задание начальной точки Х
            y = self.fp.y                         # задание начальной точки У

            if self.v_g == 0:              # если горизонтальная ориентация корабля
                x += i                 # увеличение координаты по оси х на 1

            elif self.v_g == 1:              # если вертикальная ориентация корабля
                y += i                 # увеличение координаты по оси y на 1

            ship_dots.append(Dot(x, y))  # добавление точки в список точек корабля
        return ship_dots                         # метод возвращает список точек корабля

    def shooten (self, shot):             # метод выстрел
        return shot in self.dots          # проверка принадлежат ли точки выстрела списку точек корабля

class Board:
    def __init__ (self, visible=False, size=6):                 # конструктор игровой доски. Принимает аргументы видимости и размерности игрового поля
        self.visible = visible                                  # присвение значения параметру видимости обекта
        self.size = size                                        # присвение значения параметру размерности обекта
        self.count = 0                                          # счетчик пораженных кораблей
        self.field = [[' '] * size for _ in range (size)]       # создание игрового поля
        self.busy = []                                          # список занятых точек на поле кораблем или выстрелом
        self.ships = []                                         # создание списка кораблей на доске

    def __str__(self):                                          # переопределение вывода на печать
        res = '  | 1 | 2 | 3 | 4 | 5 | 6 | '                    # задание начальной переменной
        for i, row in enumerate(self.field):                    # формирование матрицы игрового поля
            res += f'\n{i+1} | ' + ' | '.join(row) + ' | '      # формирование матрицы игрового поля

        if self.visible:                                        # условие для скрытия кораблей
            res = res.replace("■", ' ')             # замена символа корабля на 0
        return res                                              # возвращает игровое поле

    def out (self, d):                                          # метод проверки выстрела мимо поля
        return not ((0<=d.x<self.size) and (0<=d.y<self.size))  # возвращает bool

    def contur (self, ship, verb = False):                      # метод "взрыва" возле убитого корабля и невозможности разместить в этой зоне корабля
        near = [(-1,0),(0,-1),(0,0),(0,1),(1,0)]                # список взрывающихся ячейк относительно ячейки корабля
        for d in ship.dots:                                     # цикл перебора точек корабля
            for dx, dy in near:                                 # цикл взрыва точек вокруг корабля
                cur = Dot(d.x + dx, d.y + dy)                   # создание координат взрыва
                if not (self.out(cur)) and cur not in self.busy:  # проверка вхождения в область игровой доски
                    if verb:                                    # условие устанвки во ызравающуюся область символа "."
                        self.field[cur.x][cur.y] = '*'          # установка нового символа в матрицу, на место взрыва
                    self.busy.append(cur)                       # добавление точки в список занятых точек

    def add_ship (self, ship):                                  # метод добавления корабля
        for d in ship.dots:                                     # цикл перебора точек кораблся
            if self.out(d) or d in self.busy:                   # проверка на вхождение точки в игровое поле и не занятость точки
                raise BoardWrongShipException()                 # вызов исключения
        for d in ship.dots:                                     # цикл перебора точек кораблся
            self.field[d.x][d.y] = "■"                          # уставновк символа корабля в ячейку
            self.busy.append(d)                                 # добавление координат в спсико занятых точек
        self.ships.append(ship)                                 # добавление координат в спсико кораблей
        self.contur(ship)                                       # вызов метода contur

    def shot (self,d):                                          # определение метода выстрела
        if self.out(d):                                         # проверка на вхождение точки в игровое поле
            raise BoardOutException                             # вызов исключения
        if d in self.busy:                                      # проверка точки на занятость
            raise BoardUsedException                            # вызов исключения
        self.busy.append(d)                                     # добавление точки в список занятых

        for ship in self.ships:                                 # цикл перебора спика кораблей
            if ship.shooten(d):                                 # услвоие попадания в корабль
                ship.lives -= 1                                 # уменьшение количества жизней корабля
                self.field[d.x][d.y] = 'X'                      # установка на игровом поле знака Х в точке попадания
                if ship.lives == 0:                             # условие гибели корабля
                    self.count += 1                             # увеличение счетчика убитых кораблей
                    self.contur(ship, verb = True)              # отображение на доске точек взрыва от убитого корабля
                    print('Корабль уничтожен')                  # сообщение в консоль
                    if num % 2 == 1:                            # услвоия для очистки списка наиболее вероятных точек выстрела для поражения корабля в случае уничтожения корабля, применимо только к ходу компьютера
                        td = []                                 # очистка списка
                    return False                                # возвращает bool, как условие для повторного хода
                else:
                    print ('Корабль ранен')                     # сообщение в консоль
                    return True                                 # возвращает bool, как условие для повторного хода
        self.field[d.x][d.y] = '*'                              # обозначение точки выстрела "."  в случае промаха
        print('Мимо!')                                          # сообщение в консоль
        return False                                            # возвращает bool, как условие для повторного хода

    def begin (self):                                           # метод begin
        self.busy = []                                          # оищает список занятых клеток в момент старта игры

    def defeat(self):                                           # метод проверки условия на победу
        return self.count == len(self.ships)                    # сравнивает количество убитых кораблей игрока с  количеством кораблей игрока в начале игры


class Player:                                                       # объявление класса Игрока
    def __init__ (self, board, enemy):                              # конструктор класса игрока
        self.board = board                                          # присвоение знчения параметру board
        self.enemy = enemy                                          # присвоение знчения параметру enemy

    def ask (self):                                                 # Исключение, возникающее в случаях, когда наследник класса не переопределил метод, который должен был.
        raise NotImplementedError()

    def move (self):                                    # объявление метода
        while True:                                     # бесконечный цикл
            try:
                target = self.ask()                     # присвоение переменной таргет значения
                repeat = self.enemy.shot(target)        # присвоение переменной repeat значения
                return repeat                           # возвращает repeat
            except BoardException as e:                 # исключение
                print(e)


class AI (Player):                                              # класс игрока компьютера, дочерный класс Player
    def ask (self):                                             # объявление метода
        global d                                                # Объявление глобальной переменной
        if td != []:                                            # проверка наличия точек для выстрела
            h = randint (0, len(td)-1)                       # произвольный выбор точки из наиболее вероятных для поражения корабля
            d = Dot(td[h][0], td[h][1])                         # координаты точки для выстрела
            td.pop(h)                                           # удаление точки из списка наиболее вероятных
        else:
            d = Dot(randint(0,5), randint(0,5))     # создание координат выстрела генератором случайных чисел
        print(f'Ход компьютера: {d.x+1}{d.y+1}')                # сообщение в консоль
        return d                                                # возвращает координаты точки выстрела компьютера

class User(Player):                                             # класс игрока пользователя, дочерный класс Player
    def ask(self):                                              # объявление метода
        while True:                                             # бесконечный цикл
            cords = input('Ваш ход: ')                          # запрос у пользователя координат
            if cords.isdigit() and len(cords) == 2 and 1 <= int(cords[0]) <= 6 and 1 <= int(cords[1]) <= 6:         # проверка корректности ввода
                x, y = int(cords[0]), int(cords[1])                 # присвоение переменным данных введенных пользователем
                break                                           # прерывание цикла
            else: print ('Некорректный ввод, повторите')        # в случае неправильного ввода, вывод сообщения в консоль
        return Dot(x-1, y-1)                                    # возвращает координаты выстрела пользователя приведенные в соответствие


class Game:                                          # создание класса Игры
    def __init__(self, size=6):                      # конструктор класса
        self.lens = [3, 2, 2, 1, 1, 1, 1]            # список размеров кораблей
        self.size = size                             # присвоение значения параметру размеру игрового поля
        pl = self.random_board()                     # присвоение значения переменной pl из метода создания игровой доски
        co = self.random_board()                     # присвоение значения переменной co из метода создания игровой доски
        co.visible = True                            # условия видимости объектов на игровой доске
        self.ai = AI(co, pl)                         # присвоение значения параметру
        self.us = User(pl, co)                       # присвоение значения параметру
    def try_board(self):                             # метод создания игровой доски
        board = Board(size=self.size)                # вызов конструктора игровой доски
        attempts = 0                                 # счетчик попыток создания игровой доски
        for l in self.lens:                               # цикл размещения кораблей из списка на игровом поле
            while True:                              # бесконечный цикл
                attempts+=1                          # увеличение счетчика попыток создать игровое поле
                if attempts>5000:                    # если счетчик превышает 5000, то метод завершается возвращая None
                    return None                      # метод возвращет None и будет запущен с начала
                ship=Ship(Dot(randint(0,self.size), randint(0, self.size)), l, randint (0,1))    # создание корабля с помощью генератора случайных чисел
                try:
                    board.add_ship(ship)             # попытка добавить корабль на игровую доску
                    break                            # прерывание цикла в случае удачи
                except BoardWrongShipException:      # вызов исключение в случае неудачи
                    pass                             # пустое действие
        board.begin()                                # вызов метода begin класса board
        return board                                 # метод возвращает игровую доску

    def random_board(self):                         # метод бесконечных попыток создания игровой доски
        board = None                                # присвоение переменной Board  значения None
        while board is None:                        # цикл, пока Board является none вызов метода try_board
            board = self.try_board()                # присвоение переменной Board итога работы метода try_board
        return board                                # вощвращает переменную board

    def greet (self):                                                               # метод приветсвия
        print('------ Приветствуем вас в игре морской бой! -----')                  # вывод в консоль
        print("--------------- формат ввода: xy --------------- ")                  # вывод в консоль
        print("--------------- x - номер строки --------------- ")                  # вывод в консоль
        print("--------------- y - номер столбца--------------- ")                  # вывод в консоль

    def print_boards(self):                                                         #  метод распечатывания игрового поля
        print("Доска пользователя:                 Доска компьютера:")              # сообщение в консоль
        b1=str(self.us.board).split('\n')                                           # формирование поля пользователя и преобразование в список
        b2=str(self.ai.board).split('\n')                                           # формирование поля компьютера и преобразование в список
        j = 0                                                                       # счетчик элементов списка игрового поля компьютера
        for i in range(0, 14, 2):                                                   # цикл от 0 до 14 с шагом 2 для создания общего СПИСКА ЭЛЕМЕНТОВ ИГРОВОГО ПОЛЯ
            b1.insert(i + 1, b2[j])                                                 # вставка в список игрового поля ползователя элементов списка игровог ополя компьютера
            j += 1                                                                  # увеличение счетчика на 1
        for i in range(0, len(b1), 2):                                              # цикл печати игровых полей в строку
            print(b1[i] + '       ' + b1[i + 1])                                    # вывод в консоль по 2 элемента из списка


    def loop(self):                             # объявление метода
        global num
        num = 0                                 # нулевой счетчик ходов
        global td
        td = []
        while True:                             # бесконечный игровой цикл
            self.print_boards()                 # печать игрового поля
            if num % 2 == 0:                    # проверка условия чей ход,четный - пользователь, нечетный - компьютер
                print("-" * 20)                 # печать разделителя
                print("Ходит пользователь!")    # сообщение в консоль о ходе пользователя
                repeat = self.us.move()         # условия на повторение хода в случае поражения или уничтожения корабля
            else:
                print("-" * 20)                 # печать разделителя
                print("Ходит компьютер!")       # сообщение в консоль о ходе компьютера
                repeat = self.ai.move()         # условия на повторение хода в случае поражения или уничтожения корабля
                if repeat and td == []:         # условие для создания списка наиболее вероятных точек для поражения
                    for i in range(-1, 2, 2):   # цикл формирования списка точек для выстрела исходя из пораженной точки корабля
                        nl = [d.x + i, d.y]     # создание элемента списка
                        nl2 = [d.x, d.y + i]    # создание элемента списка
                        td.append(nl)           # добавление элемента в список
                        td.append(nl2)          # добавление элемента в список
            if repeat:                          # если было попадание, то счетчик ходов уменьшается на 1
                num -= 1                        # уменьшение счетчика ходов
            if self.ai.board.defeat():            # проверка условия на выигрыш пользователя методом defeat, сравнение кол-ва пораженных кораблей и длинной списка созданных кораблей
                self.print_boards()               # вывод в консоль финального игрового поля
                print("-" * 20)                   # печать разделителя
                print("Пользователь выиграл!")    # сообщение в консоль о победе пользователя
                break                             # прерывание цикла, конец игры
            if self.us.board.defeat():            # проверка условия на выигрыш пользователя методом defeat, сравнение кол-ва пораженных кораблей и длинной списка созданных кораблей
                self.print_boards()               # вывод в консоль финального игрового поля
                print("-" * 20)                   # печать разделителя
                print("Компьютер выиграл!")       # сообщение в консоль о победе компьютера
                break                             # прерывание цикла, конец игры
            num += 1                              # счетчик ходов

    def start(self):           # метод начала игры
        self.greet()           # вызов приветственного метода
        self.loop()            # вызов метода игрового цикла


g = Game()          # присвоение переменной g класса Game
g.start()           # вызов метода  start класса Game


